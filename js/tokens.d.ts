import * as chevrotain from 'chevrotain';
export declare const Tokens: {
    all: chevrotain.TokenConstructor;
    and: chevrotain.TokenConstructor;
    a: chevrotain.TokenConstructor;
    AnANY: chevrotain.TokenConstructor;
    any: chevrotain.TokenConstructor;
    at: chevrotain.TokenConstructor;
    CAT: chevrotain.TokenConstructor;
    Comma: chevrotain.TokenConstructor;
    containing: chevrotain.TokenConstructor;
    contains: chevrotain.TokenConstructor;
    DOM: chevrotain.TokenConstructor;
    domain: chevrotain.TokenConstructor;
    ending_with: chevrotain.TokenConstructor;
    ending: chevrotain.TokenConstructor;
    ends_with: chevrotain.TokenConstructor;
    ends: chevrotain.TokenConstructor;
    EQ: chevrotain.TokenConstructor;
    equals: chevrotain.TokenConstructor;
    every: chevrotain.TokenConstructor;
    exactly: chevrotain.TokenConstructor;
    existing: chevrotain.TokenConstructor;
    e: chevrotain.TokenConstructor;
    FACT: chevrotain.TokenConstructor;
    first: chevrotain.TokenConstructor;
    for: chevrotain.TokenConstructor;
    from: chevrotain.TokenConstructor;
    GE: chevrotain.TokenConstructor;
    greater: chevrotain.TokenConstructor;
    GT: chevrotain.TokenConstructor;
    in: chevrotain.TokenConstructor;
    is: chevrotain.TokenConstructor;
    last: chevrotain.TokenConstructor;
    latest: chevrotain.TokenConstructor;
    LE: chevrotain.TokenConstructor;
    least: chevrotain.TokenConstructor;
    leat: chevrotain.TokenConstructor;
    left_paren: chevrotain.TokenConstructor;
    less_than: chevrotain.TokenConstructor;
    less: chevrotain.TokenConstructor;
    life: chevrotain.TokenConstructor;
    list: chevrotain.TokenConstructor;
    logical_and: chevrotain.TokenConstructor;
    logical_or: chevrotain.TokenConstructor;
    LParen: chevrotain.TokenConstructor;
    LT: chevrotain.TokenConstructor;
    more_than: chevrotain.TokenConstructor;
    NE: chevrotain.TokenConstructor;
    newest: chevrotain.TokenConstructor;
    not_existing: chevrotain.TokenConstructor;
    of: chevrotain.TokenConstructor;
    oldest: chevrotain.TokenConstructor;
    one: chevrotain.TokenConstructor;
    order_by: chevrotain.TokenConstructor;
    order_descending_by: chevrotain.TokenConstructor;
    or: chevrotain.TokenConstructor;
    relating: chevrotain.TokenConstructor;
    right_paren: chevrotain.TokenConstructor;
    RParen: chevrotain.TokenConstructor;
    select: chevrotain.TokenConstructor;
    short: chevrotain.TokenConstructor;
    starting_with: chevrotain.TokenConstructor;
    starting: chevrotain.TokenConstructor;
    starts_with: chevrotain.TokenConstructor;
    starts: chevrotain.TokenConstructor;
    than: chevrotain.TokenConstructor;
    the: chevrotain.TokenConstructor;
    where: chevrotain.TokenConstructor;
    with: chevrotain.TokenConstructor;
    Integer: chevrotain.TokenConstructor;
    Identifier: chevrotain.TokenConstructor;
};
export declare const OperatorLookup: {
    all: chevrotain.TokenConstructor;
    and: chevrotain.TokenConstructor;
    a: chevrotain.TokenConstructor;
    AnANY: chevrotain.TokenConstructor;
    any: chevrotain.TokenConstructor;
    at: chevrotain.TokenConstructor;
    CAT: chevrotain.TokenConstructor;
    ",": chevrotain.TokenConstructor;
    containing: chevrotain.TokenConstructor;
    contains: chevrotain.TokenConstructor;
    DOM: chevrotain.TokenConstructor;
    domain: chevrotain.TokenConstructor;
    "ending with": chevrotain.TokenConstructor;
    ending: chevrotain.TokenConstructor;
    "ends with": chevrotain.TokenConstructor;
    ends: chevrotain.TokenConstructor;
    "=": chevrotain.TokenConstructor;
    equals: chevrotain.TokenConstructor;
    every: chevrotain.TokenConstructor;
    exactly: chevrotain.TokenConstructor;
    existing: chevrotain.TokenConstructor;
    e: chevrotain.TokenConstructor;
    FACT: chevrotain.TokenConstructor;
    first: chevrotain.TokenConstructor;
    for: chevrotain.TokenConstructor;
    from: chevrotain.TokenConstructor;
    ">=": chevrotain.TokenConstructor;
    greater: chevrotain.TokenConstructor;
    ">": chevrotain.TokenConstructor;
    in: chevrotain.TokenConstructor;
    is: chevrotain.TokenConstructor;
    last: chevrotain.TokenConstructor;
    latest: chevrotain.TokenConstructor;
    "<=": chevrotain.TokenConstructor;
    least: chevrotain.TokenConstructor;
    leat: chevrotain.TokenConstructor;
    left_paren: chevrotain.TokenConstructor;
    "less than": chevrotain.TokenConstructor;
    less: chevrotain.TokenConstructor;
    life: chevrotain.TokenConstructor;
    list: chevrotain.TokenConstructor;
    logical_and: chevrotain.TokenConstructor;
    logical_or: chevrotain.TokenConstructor;
    "(": chevrotain.TokenConstructor;
    "<": chevrotain.TokenConstructor;
    "more than": chevrotain.TokenConstructor;
    "!=": chevrotain.TokenConstructor;
    newest: chevrotain.TokenConstructor;
    "not existing": chevrotain.TokenConstructor;
    of: chevrotain.TokenConstructor;
    oldest: chevrotain.TokenConstructor;
    one: chevrotain.TokenConstructor;
    "order by": chevrotain.TokenConstructor;
    "order descending by": chevrotain.TokenConstructor;
    or: chevrotain.TokenConstructor;
    relating: chevrotain.TokenConstructor;
    right_paren: chevrotain.TokenConstructor;
    ")": chevrotain.TokenConstructor;
    select: chevrotain.TokenConstructor;
    short: chevrotain.TokenConstructor;
    "starting with": chevrotain.TokenConstructor;
    starting: chevrotain.TokenConstructor;
    "starts with": chevrotain.TokenConstructor;
    starts: chevrotain.TokenConstructor;
    than: chevrotain.TokenConstructor;
    the: chevrotain.TokenConstructor;
    where: chevrotain.TokenConstructor;
    with: chevrotain.TokenConstructor;
    123: chevrotain.TokenConstructor;
    identifier: chevrotain.TokenConstructor;
};
