"use strict";
/**
 * Functionality managing the match models
 *
 * @file
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongooseNLQ = exports.MongoNLQ = exports.getModelDocFromDB = exports.getExtendSchemaDocFromDB = exports.getOperatorsFromDB = exports.getFillersFromDB = exports.makeMongoCollectionName = exports.augmentMongooseSchema = exports.loadModelDoc = exports.loadExtendedMongooseSchema = exports.typeProps = exports.replaceIfTypeDeleteM = exports.mapType = exports.loadModelNames = exports.cmpTools = void 0;
//import * as intf from 'constants';
const debug = require("debugf");
var debuglog = debug('schemaload');
const FUtils = require("../model/model");
//import * as CircularSer from 'abot_utils';
//import * as Distance from 'abot_stringdist';
const process = require("process");
const _ = require("lodash");
const console_1 = require("console");
/**
 * WATCH out, this instruments srcHandle!
 */
// require('srcHandle-schema-jsonschema')(srcHandle);
/**
 * the model path, may be controlled via environment variable
 */
var envModelPath = process.env["ABOT_MODELPATH"] || "node_modules/abot_testmodel/testmodel";
function cmpTools(a, b) {
    return a.name.localeCompare(b.name);
}
exports.cmpTools = cmpTools;
const ExtendedSchema_props = {
    "modelname": {
        "type": String,
        "trim": true,
        "required": true
    },
    "domain": {
        "type": String,
        "trim": true,
        "required": true
    },
    "mongoosemodelname": {
        "type": String,
        "trim": true,
        "required": true
    },
    "collectionname": {
        "type": String,
        "trim": true,
        "required": true
    },
    "props": {},
    "index": {}
};
const ExtendedSchema_index = {
    "modelname": "text"
};
// load the models
function loadModelNames(modelPath) {
    modelPath = modelPath || envModelPath;
    debuglog(() => `modelpath is ${modelPath} `);
    var mdls = FUtils.readFileAsJSON(modelPath + '/models.json');
    mdls.forEach(name => {
        if (name !== makeMongoCollectionName(name)) {
            throw new Error('bad modelname, must terminate with s and be lowercase');
        }
    });
    return mdls;
}
exports.loadModelNames = loadModelNames;
;
function mapType(val) {
    if (val === "String") {
        return String;
    }
    if (val === "Boolean") {
        return Boolean;
    }
    if (val === "Number") {
        return Number;
    }
    throw new Error(" illegal type " + val + " expected String, Boolean, Number, ...");
}
exports.mapType = mapType;
function replaceIfTypeDeleteM(obj, val, key) {
    if (key.substr(0, 3) === "_m_") {
        delete obj[key];
        return;
    }
    ;
    if (key === "type" && typeof val === "string") {
        var r = mapType(val);
        obj[key] = r;
    }
}
exports.replaceIfTypeDeleteM = replaceIfTypeDeleteM;
function traverseExecuting(obj, fn) {
    _.forIn(obj, function (val, key) {
        //    console.log(val + " -> " + key + " ");
        fn(obj, val, key);
        if (_.isArray(val)) {
            val.forEach(function (el) {
                if (_.isObject(el)) {
                    traverseExecuting(el, fn);
                }
            });
        }
        if (_.isObject(val)) {
            traverseExecuting(obj[key], fn);
        }
    });
}
function traverseReplacingType(obj) {
    return traverseExecuting(obj, replaceIfTypeDeleteM);
    /*
    _.forIn(obj, function (val, key) {
    //    console.log(val + " -> " + key + " ");
        replaceIfTypeDeleteM(obj,val,key);
        if (_.isArray(val)) {
            val.forEach(function(el) {
                if (_.isObject(el)) {
                    traverseReplacingType(el);
                }
            });
        }
        if (_.isObject(val)) {
            traverseReplacingType(obj[key]);
        }
    });
    */
}
function typeProps(a) {
    var aCloned = _.cloneDeep(a);
    //console.log(JSON.stringify(aCloned, undefined, 2));
    traverseReplacingType(aCloned);
    return aCloned;
}
exports.typeProps = typeProps;
function loadExtendedMongooseSchema(modelPath, modelName) {
    var filename = modelPath + '/' + modelName + '.model.mongooseschema.json';
    debuglog(() => `attempting to read ${filename}`);
    var schemaSer = FUtils.readFileAsJSON(filename);
    schemaSer.modelName = modelName;
    return schemaSer;
}
exports.loadExtendedMongooseSchema = loadExtendedMongooseSchema;
function loadModelDoc(modelPath, modelName) {
    var docSer = FUtils.readFileAsJSON(modelPath + '/' + modelName + '.model.doc.json');
    docSer.modelname = modelName;
    return docSer;
}
exports.loadModelDoc = loadModelDoc;
var aPromise = global.Promise;
;
function augmentMongooseSchema(modelDoc, schemaRaw) {
    debuglog(() => 'augmenting for ' + modelDoc.modelname);
    var res = { domain: modelDoc.domain,
        modelname: modelDoc.modelname
    };
    return Object.assign(res, schemaRaw);
}
exports.augmentMongooseSchema = augmentMongooseSchema;
/**
 * returns a srcHandle collection name
 * @param modelName
 */
function makeMongoCollectionName(modelName) {
    console_1.assert(modelName == modelName.toLowerCase());
    return modelName;
}
exports.makeMongoCollectionName = makeMongoCollectionName;
var SchemaOperators = { operators: {}, synonyms: {} };
var SchemaFillers = { fillers: [{
            type: String
        }]
};
function getFillersFromDB(srcHandle) {
    return srcHandle.getJSON("filler.json");
}
exports.getFillersFromDB = getFillersFromDB;
function getOperatorsFromDB(srcHandle) {
    return srcHandle.getJSON('operators.json');
}
exports.getOperatorsFromDB = getOperatorsFromDB;
function getExtendSchemaDocFromDB(srcHandle, modelName) {
    var mongooseModelName = modelName;
    //var model_ES = srcHandle.model(MongooseNLQ.MONGOOSE_MODELNAME_EXTENDEDSCHEMAS);
    var res = srcHandle.getJSONArr(modelName + ".model.mongooseschema.json") /*model_ES.find({ modelname : modelName}).lean().exec()
    */
        .then((doc) => {
        doc[0].modelname = modelName;
        debuglog(() => ` loaded Es doc ${modelName} returned ${doc.length} docus from db : `
            + doc[0].modelname + `` + doc[0].collectionname);
        debuglog(() => 'here the result' + JSON.stringify(doc));
        return doc[0];
    });
    return res;
}
exports.getExtendSchemaDocFromDB = getExtendSchemaDocFromDB;
function getModelDocFromDB(srcHandle, modelName) {
    return srcHandle.getJSON(modelName + ".model.doc.json")
        .then((doc) => {
        doc.modelname = modelName;
        debuglog(() => ' loaded Model doc ${modelName} from db : '
            + (doc.modelname));
        debuglog('here the result' + JSON.stringify(doc));
        return doc;
    });
}
exports.getModelDocFromDB = getModelDocFromDB;
exports.MongoNLQ = {
    MODELNAME_METAMODELS: "metamodels",
    COLL_METAMODELS: "metamodels",
};
exports.MongooseNLQ = {
    MONGOOSE_MODELNAME_METAMODELS: "metamodels"
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tb2RlbGxvYWQvc2NoZW1hbG9hZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7R0FJRzs7O0FBRUgsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUVoQyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7QUFTbkMseUNBQXlDO0FBSXpDLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUU1QixxQ0FBaUM7QUFFakM7O0dBRUc7QUFDSCxxREFBcUQ7QUFDckQ7O0dBRUc7QUFDSCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksdUNBQXVDLENBQUM7QUFFNUYsU0FBZ0IsUUFBUSxDQUFDLENBQWUsRUFBRSxDQUFlO0lBQ3ZELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFGRCw0QkFFQztBQU9ELE1BQU0sb0JBQW9CLEdBQUc7SUFDekIsV0FBVyxFQUFFO1FBQ1gsTUFBTSxFQUFFLE1BQU07UUFDZCxNQUFNLEVBQUUsSUFBSTtRQUNaLFVBQVUsRUFBRyxJQUFJO0tBQ2xCO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsTUFBTSxFQUFFLE1BQU07UUFDZCxNQUFNLEVBQUUsSUFBSTtRQUNaLFVBQVUsRUFBRyxJQUFJO0tBQ2xCO0lBQ0QsbUJBQW1CLEVBQUU7UUFDbkIsTUFBTSxFQUFFLE1BQU07UUFDZCxNQUFNLEVBQUUsSUFBSTtRQUNaLFVBQVUsRUFBRyxJQUFJO0tBQ2xCO0lBQ0QsZ0JBQWdCLEVBQUU7UUFDaEIsTUFBTSxFQUFFLE1BQU07UUFDZCxNQUFNLEVBQUUsSUFBSTtRQUNaLFVBQVUsRUFBRyxJQUFJO0tBQ2xCO0lBQ0QsT0FBTyxFQUFHLEVBQUU7SUFDWixPQUFPLEVBQUcsRUFBRTtDQUNmLENBQUM7QUFDRixNQUFNLG9CQUFvQixHQUFH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QUFHLEVBQUUsQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDeEQsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFiRCw0REFhQztBQUVELFNBQWdCLGlCQUFpQixDQUFDLFNBQXNCLEVBQUUsU0FBa0I7SUFDeEUsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQztTQUN0RCxJQUFJLENBQUMsQ0FBQyxHQUFlLEVBQUUsRUFBRTtRQUVsQixHQUFHLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMxQixRQUFRLENBQUUsR0FBRSxFQUFFLENBQUMsMkNBQTJDO2NBQ3hELENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFFLENBQUM7UUFDcEIsUUFBUSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUMsQ0FDSixDQUFDO0FBQ04sQ0FBQztBQVhELDhDQVdDO0FBRVksUUFBQSxRQUFRLEdBQUc7SUFDcEIsb0JBQW9CLEVBQUcsWUFBWTtJQUNuQyxlQUFlLEVBQUcsWUFBWTtDQUNqQyxDQUFDO0FBRVcsUUFBQSxXQUFXLEdBQUc7SUFDdkIsNkJBQTZCLEVBQUcsWUFBWTtDQUMvQyxDQUFDIiwiZmlsZSI6Im1vZGVsbG9hZC9zY2hlbWFsb2FkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEZ1bmN0aW9uYWxpdHkgbWFuYWdpbmcgdGhlIG1hdGNoIG1vZGVsc1xyXG4gKlxyXG4gKiBAZmlsZVxyXG4gKi9cclxuXHJcbi8vaW1wb3J0ICogYXMgaW50ZiBmcm9tICdjb25zdGFudHMnO1xyXG5pbXBvcnQgKiBhcyBkZWJ1ZyBmcm9tICdkZWJ1Z2YnO1xyXG5cclxudmFyIGRlYnVnbG9nID0gZGVidWcoJ3NjaGVtYWxvYWQnKTtcclxuXHJcbi8vY29uc3QgbG9hZGxvZyA9IGxvZ2dlci5sb2dnZXIoJ21vZGVsbG9hZCcsICcnKTtcclxuXHJcbmltcG9ydCAqICBhcyBJTWF0Y2ggZnJvbSAnLi4vbWF0Y2gvaWZtYXRjaCc7XHJcbi8vaW1wb3J0ICogYXMgSW5wdXRGaWx0ZXJSdWxlcyBmcm9tICcuLi9tYXRjaC9ydWxlJztcclxuLy9pbXBvcnQgKiBhcyBUb29scyBmcm9tICcuLi9tYXRjaC90b29scyc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0ICogYXMgTWV0YSBmcm9tICcuLi9tb2RlbC9tZXRhJztcclxuaW1wb3J0ICogYXMgRlV0aWxzIGZyb20gJy4uL21vZGVsL21vZGVsJztcclxuaW1wb3J0IHsgSUZNb2RlbCBhcyBJRk1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvaW5kZXhfbW9kZWwnO1xyXG5pbXBvcnQgKiBhcyBNb25nb01hcCBmcm9tICcuLi9tb2RlbC9tb25nb21hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJ2Fib3RfdXRpbHMnO1xyXG4vL2ltcG9ydCAqIGFzIENpcmN1bGFyU2VyIGZyb20gJ2Fib3RfdXRpbHMnO1xyXG4vL2ltcG9ydCAqIGFzIERpc3RhbmNlIGZyb20gJ2Fib3Rfc3RyaW5nZGlzdCc7XHJcbmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgSVNyY0hhbmRsZSAsIElQc2V1ZG9TY2hlbWEsIElQc2V1ZG9Nb2RlbCB9IGZyb20gJy4uL21vZGVsL3NyY2hhbmRsZSc7XHJcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ2NvbnNvbGUnO1xyXG5cclxuLyoqXHJcbiAqIFdBVENIIG91dCwgdGhpcyBpbnN0cnVtZW50cyBzcmNIYW5kbGUhXHJcbiAqL1xyXG4vLyByZXF1aXJlKCdzcmNIYW5kbGUtc2NoZW1hLWpzb25zY2hlbWEnKShzcmNIYW5kbGUpO1xyXG4vKipcclxuICogdGhlIG1vZGVsIHBhdGgsIG1heSBiZSBjb250cm9sbGVkIHZpYSBlbnZpcm9ubWVudCB2YXJpYWJsZVxyXG4gKi9cclxudmFyIGVudk1vZGVsUGF0aCA9IHByb2Nlc3MuZW52W1wiQUJPVF9NT0RFTFBBVEhcIl0gfHwgXCJub2RlX21vZHVsZXMvYWJvdF90ZXN0bW9kZWwvdGVzdG1vZGVsXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY21wVG9vbHMoYTogSU1hdGNoLklUb29sLCBiOiBJTWF0Y2guSVRvb2wpIHtcclxuICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcclxufVxyXG5cclxuXHJcbnR5cGUgSU1vZGVsID0gSU1hdGNoLklNb2RlbDtcclxuXHJcbnR5cGUgSU1vZGVsRG9jID0gSU1hdGNoLklNb2RlbERvYztcclxuXHJcbmNvbnN0IEV4dGVuZGVkU2NoZW1hX3Byb3BzID0ge1xyXG4gICAgXCJtb2RlbG5hbWVcIjoge1xyXG4gICAgICBcInR5cGVcIjogU3RyaW5nLFxyXG4gICAgICBcInRyaW1cIjogdHJ1ZSxcclxuICAgICAgXCJyZXF1aXJlZFwiIDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwiZG9tYWluXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFN0cmluZyxcclxuICAgICAgXCJ0cmltXCI6IHRydWUsXHJcbiAgICAgIFwicmVxdWlyZWRcIiA6IHRydWVcclxuICAgIH0sXHJcbiAgICBcIm1vbmdvb3NlbW9kZWxuYW1lXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFN0cmluZyxcclxuICAgICAgXCJ0cmltXCI6IHRydWUsXHJcbiAgICAgIFwicmVxdWlyZWRcIiA6IHRydWVcclxuICAgIH0sXHJcbiAgICBcImNvbGxlY3Rpb25uYW1lXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFN0cmluZyxcclxuICAgICAgXCJ0cmltXCI6IHRydWUsXHJcbiAgICAgIFwicmVxdWlyZWRcIiA6IHRydWVcclxuICAgIH0sXHJcbiAgICBcInByb3BzXCIgOiB7fSxcclxuICAgIFwiaW5kZXhcIiA6IHt9XHJcbn07XHJcbmNvbnN0IEV4dGVuZGVkU2NoZW1hX2luZGV4ID0ge1xyXG4gICAgXCJtb2RlbG5hbWVcIiA6IFwidGV4dFwiXHJcbn07XHJcblxyXG5cclxuXHJcbi8vIGxvYWQgdGhlIG1vZGVsc1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRNb2RlbE5hbWVzKG1vZGVsUGF0aCA6IHN0cmluZykgOiBzdHJpbmdbXSB7XHJcbiAgbW9kZWxQYXRoID0gbW9kZWxQYXRoIHx8IGVudk1vZGVsUGF0aDtcclxuICBkZWJ1Z2xvZygoKT0+IGBtb2RlbHBhdGggaXMgJHttb2RlbFBhdGh9IGApO1xyXG4gIHZhciBtZGxzID0gRlV0aWxzLnJlYWRGaWxlQXNKU09OKG1vZGVsUGF0aCArICcvbW9kZWxzLmpzb24nKTtcclxuICBtZGxzLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICBpZihuYW1lICE9PSBtYWtlTW9uZ29Db2xsZWN0aW9uTmFtZShuYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIG1vZGVsbmFtZSwgbXVzdCB0ZXJtaW5hdGUgd2l0aCBzIGFuZCBiZSBsb3dlcmNhc2UnKTtcclxuICAgIH1cclxuICB9KVxyXG4gIHJldHVybiBtZGxzO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElSYXdTY2hlbWEge1xyXG4gICAgcHJvcHM6IGFueVtdLFxyXG4gICAgaW5kZXggOiBhbnlcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGludGVyZmFjZSBJTW9kZWxEb2NDYXRlZ29yeVJlYyB7XHJcbiAgICBjYXRlZ29yeSA6IHN0cmluZyxcclxuICAgIGNhdGVnb3J5X2Rlc2NyaXB0aW9uIDogc3RyaW5nLFxyXG4gICAgUUJFQ29sdW1uUHJvcHMgOiB7XHJcbiAgICAgICAgXCJkZWZhdWx0V2lkdGhcIjogbnVtYmVyLFxyXG4gICAgICAgIFwiUUJFXCI6IGJvb2xlYW4sXHJcbiAgICAgICAgXCJMVU5SSW5kZXhcIjogYm9vbGVhblxyXG4gICAgICB9LFxyXG4gICAgICBcImNhdGVnb3J5X3N5bm9ueW1zXCI6IHN0cmluZ1tdLFxyXG4gICAgd29yZGluZGV4IDogYm9vbGVhbixcclxuICAgIGV4YWN0bWF0Y2g6IGJvb2xlYW4sXHJcbiAgICBzaG93TVxyXG59O1xyXG4qL1xyXG5cclxuXHJcbi8qXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1vZGVsRG9jIHtcclxuICAgIGRvbWFpbiA6IHN0cmluZyxcclxuICAgIG1vZGVsbmFtZT8gOiBzdHJpbmcsXHJcbiAgICBjb2xsZWN0aW9ubmFtZT8gOiBzdHJpbmcsXHJcbiAgICBkb21haW5fZGVzY3JpcHRpb24gOiBzdHJpbmdcclxuICAgIF9jYXRlZ29yaWVzIDogSU1hdGNoLklNb2RlbENhdGVnb3J5UmVjW10sXHJcbiAgICBjb2x1bW5zOiBzdHJpbmdbXSxcclxuICAgIGRvbWFpbl9zeW5vbnltcyA6IHN0cmluZ1tdXHJcblxyXG59Ki9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUV4dGVuZGVkU2NoZW1hIGV4dGVuZHMgSVJhd1NjaGVtYXtcclxuICAgIGRvbWFpbiA6IHN0cmluZyxcclxuICAgIG1vZGVsbmFtZSA6IHN0cmluZ1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcFR5cGUodmFsIDogc3RyaW5nKSA6IGFueSB7XHJcbiAgICBpZih2YWwgPT09IFwiU3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgaWYodmFsID09PSBcIkJvb2xlYW5cIikge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuO1xyXG4gICAgfVxyXG4gICAgaWYodmFsID09PSBcIk51bWJlclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcjtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIiBpbGxlZ2FsIHR5cGUgXCIgKyB2YWwgKyBcIiBleHBlY3RlZCBTdHJpbmcsIEJvb2xlYW4sIE51bWJlciwgLi4uXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUlmVHlwZURlbGV0ZU0ob2JqIDogYW55LCB2YWwgOiBhbnksIGtleSA6IHN0cmluZykge1xyXG4gICAgaWYoa2V5LnN1YnN0cigwLDMpID09PSBcIl9tX1wiKSB7XHJcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH07XHJcbiAgICBpZihrZXkgPT09IFwidHlwZVwiICYmIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB2YXIgciA9IG1hcFR5cGUodmFsKTtcclxuICAgICAgICBvYmpba2V5XSA9IHI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYXZlcnNlRXhlY3V0aW5nKG9iaiwgZm4gKSB7XHJcbiAgICBfLmZvckluKG9iaiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XHJcbiAgICAvLyAgICBjb25zb2xlLmxvZyh2YWwgKyBcIiAtPiBcIiArIGtleSArIFwiIFwiKTtcclxuICAgICAgICBmbihvYmosdmFsLGtleSk7XHJcbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdChlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZUV4ZWN1dGluZyhlbCxmbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc09iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlRXhlY3V0aW5nKG9ialtrZXldLGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhdmVyc2VSZXBsYWNpbmdUeXBlKG9iaikge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlRXhlY3V0aW5nKG9iaixyZXBsYWNlSWZUeXBlRGVsZXRlTSk7XHJcbiAgICAvKlxyXG4gICAgXy5mb3JJbihvYmosIGZ1bmN0aW9uICh2YWwsIGtleSkge1xyXG4gICAgLy8gICAgY29uc29sZS5sb2codmFsICsgXCIgLT4gXCIgKyBrZXkgKyBcIiBcIik7XHJcbiAgICAgICAgcmVwbGFjZUlmVHlwZURlbGV0ZU0ob2JqLHZhbCxrZXkpO1xyXG4gICAgICAgIGlmIChfLmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VSZXBsYWNpbmdUeXBlKGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2VSZXBsYWNpbmdUeXBlKG9ialtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgICovXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0eXBlUHJvcHMoYSA6IGFueSkgOiBhbnkge1xyXG4gICB2YXIgYUNsb25lZCA9IF8uY2xvbmVEZWVwKGEpO1xyXG4gICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGFDbG9uZWQsIHVuZGVmaW5lZCwgMikpO1xyXG4gICB0cmF2ZXJzZVJlcGxhY2luZ1R5cGUoYUNsb25lZCk7XHJcbiAgIHJldHVybiBhQ2xvbmVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZEV4dGVuZGVkTW9uZ29vc2VTY2hlbWEobW9kZWxQYXRoOiBzdHJpbmcsIG1vZGVsTmFtZSA6IHN0cmluZyk6IElFeHRlbmRlZFNjaGVtYSB7XHJcbiAgdmFyIGZpbGVuYW1lID0gIG1vZGVsUGF0aCArICcvJyArIG1vZGVsTmFtZSArICcubW9kZWwubW9uZ29vc2VzY2hlbWEuanNvbic7XHJcbiAgZGVidWdsb2coKCk9PiBgYXR0ZW1wdGluZyB0byByZWFkICR7ZmlsZW5hbWV9YClcclxuICB2YXIgc2NoZW1hU2VyID0gRlV0aWxzLnJlYWRGaWxlQXNKU09OKGZpbGVuYW1lKTtcclxuICBzY2hlbWFTZXIubW9kZWxOYW1lID0gbW9kZWxOYW1lO1xyXG4gIHJldHVybiBzY2hlbWFTZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkTW9kZWxEb2MobW9kZWxQYXRoOiBzdHJpbmcsIG1vZGVsTmFtZSA6IHN0cmluZyk6IElNb2RlbERvYyB7XHJcbiAgdmFyIGRvY1NlciA9IEZVdGlscy5yZWFkRmlsZUFzSlNPTiggbW9kZWxQYXRoICsgJy8nICsgbW9kZWxOYW1lICsgJy5tb2RlbC5kb2MuanNvbicpO1xyXG4gIGRvY1Nlci5tb2RlbG5hbWUgPSBtb2RlbE5hbWU7XHJcbiAgcmV0dXJuIGRvY1NlcjtcclxufVxyXG5cclxudmFyIGFQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElNb2RlbFJlYyAge1xyXG4gICAgY29sbGVjdGlvbk5hbWUgOiBzdHJpbmcsXHJcbiAgICBtb2RlbCA6IElQc2V1ZG9Nb2RlbCxcclxuICAgIHNjaGVtYSA6IElQc2V1ZG9TY2hlbWFcclxufTtcclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXVnbWVudE1vbmdvb3NlU2NoZW1hKCBtb2RlbERvYyA6IElNb2RlbERvYywgc2NoZW1hUmF3IDogSVJhd1NjaGVtYSkgOiBJRXh0ZW5kZWRTY2hlbWEge1xyXG4gICAgZGVidWdsb2coICgpPT4nYXVnbWVudGluZyBmb3IgJyArIG1vZGVsRG9jLm1vZGVsbmFtZSk7XHJcbiAgICB2YXIgcmVzID0geyBkb21haW4gOiBtb2RlbERvYy5kb21haW4sXHJcbiAgICAgICAgbW9kZWxuYW1lIDogbW9kZWxEb2MubW9kZWxuYW1lXHJcbiAgICAgfSBhcyBJRXh0ZW5kZWRTY2hlbWE7XHJcbiAgICByZXR1cm4gKE9iamVjdCBhcyBhbnkpLmFzc2lnbihyZXMsIHNjaGVtYVJhdyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGEgc3JjSGFuZGxlIGNvbGxlY3Rpb24gbmFtZVxyXG4gKiBAcGFyYW0gbW9kZWxOYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1vbmdvQ29sbGVjdGlvbk5hbWUobW9kZWxOYW1lIDogc3RyaW5nKSA6IHN0cmluZyB7XHJcbiAgICBhc3NlcnQoIG1vZGVsTmFtZSA9PSBtb2RlbE5hbWUudG9Mb3dlckNhc2UoKSk7IFxyXG4gICAgcmV0dXJuIG1vZGVsTmFtZTsgXHJcbn1cclxuXHJcbnZhciBTY2hlbWFPcGVyYXRvcnMgPSB7IG9wZXJhdG9ycyA6IHt9LCBzeW5vbnltcyA6IHt9fTtcclxuXHJcbnZhciBTY2hlbWFGaWxsZXJzID0geyBmaWxsZXJzIDogW3tcclxuICAgIHR5cGUgOiBTdHJpbmdcclxufV1cclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxsZXJzRnJvbURCKCBzcmNIYW5kbGUgOiBJU3JjSGFuZGxlKSA6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgIHJldHVybiBzcmNIYW5kbGUuZ2V0SlNPTihcImZpbGxlci5qc29uXCIpIGFzIFByb21pc2U8c3RyaW5nW10+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0b3JzRnJvbURCKCBzcmNIYW5kbGUgOiBJU3JjSGFuZGxlKSA6IFByb21pc2U8YW55PiB7XHJcbiAgICByZXR1cm4gc3JjSGFuZGxlLmdldEpTT04oJ29wZXJhdG9ycy5qc29uJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbmRTY2hlbWFEb2NGcm9tREIoc3JjSGFuZGxlIDogSVNyY0hhbmRsZSwgbW9kZWxOYW1lIDogc3RyaW5nKSA6IFByb21pc2U8SUV4dGVuZGVkU2NoZW1hPiB7XHJcbiAgICB2YXIgbW9uZ29vc2VNb2RlbE5hbWUgPSBtb2RlbE5hbWU7XHJcbiAgICAvL3ZhciBtb2RlbF9FUyA9IHNyY0hhbmRsZS5tb2RlbChNb25nb29zZU5MUS5NT05HT09TRV9NT0RFTE5BTUVfRVhURU5ERURTQ0hFTUFTKTtcclxuICAgIHZhciByZXMgPSBzcmNIYW5kbGUuZ2V0SlNPTkFycihtb2RlbE5hbWUgKyBcIi5tb2RlbC5tb25nb29zZXNjaGVtYS5qc29uXCIpIC8qbW9kZWxfRVMuZmluZCh7IG1vZGVsbmFtZSA6IG1vZGVsTmFtZX0pLmxlYW4oKS5leGVjKClcclxuICAgICovXHJcbiAgICAgIC50aGVuKChkb2MpID0+XHJcbiAgICB7ICAgZG9jWzBdLm1vZGVsbmFtZSA9IG1vZGVsTmFtZTsgXHJcbiAgICAgICAgZGVidWdsb2coICgpPT4gYCBsb2FkZWQgRXMgZG9jICR7bW9kZWxOYW1lfSByZXR1cm5lZCAkeyhkb2MgYXMgYW55KS5sZW5ndGh9IGRvY3VzIGZyb20gZGIgOiBgXHJcbiAgICAgICAgKyAoZG9jIGFzIGFueSlbMF0ubW9kZWxuYW1lICsgYGAgKyAoZG9jIGFzIGFueSlbMF0uY29sbGVjdGlvbm5hbWUgKTtcclxuICAgICAgICBkZWJ1Z2xvZygoKSA9PiAnaGVyZSB0aGUgcmVzdWx0JyArIEpTT04uc3RyaW5naWZ5KGRvYykpO1xyXG4gICAgICAgIHJldHVybiBkb2NbMF07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbERvY0Zyb21EQihzcmNIYW5kbGUgOiBJU3JjSGFuZGxlLCBtb2RlbE5hbWUgOiBzdHJpbmcpIDogUHJvbWlzZTxJTW9kZWxEb2M+IHtcclxuICAgIHJldHVybiBzcmNIYW5kbGUuZ2V0SlNPTihtb2RlbE5hbWUgKyBcIi5tb2RlbC5kb2MuanNvblwiKVxyXG4gICAgLnRoZW4oKGRvYyA6IElNb2RlbERvYykgPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvYy5tb2RlbG5hbWUgPSBtb2RlbE5hbWU7XHJcbiAgICAgICAgICAgIGRlYnVnbG9nKCAoKT0+ICcgbG9hZGVkIE1vZGVsIGRvYyAke21vZGVsTmFtZX0gZnJvbSBkYiA6ICdcclxuICAgICAgICAgICAgKyAoZG9jLm1vZGVsbmFtZSkgKTtcclxuICAgICAgICAgICAgZGVidWdsb2coJ2hlcmUgdGhlIHJlc3VsdCcgKyBKU09OLnN0cmluZ2lmeShkb2MpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTW9uZ29OTFEgPSB7XHJcbiAgICBNT0RFTE5BTUVfTUVUQU1PREVMUyA6IFwibWV0YW1vZGVsc1wiLFxyXG4gICAgQ09MTF9NRVRBTU9ERUxTIDogXCJtZXRhbW9kZWxzXCIsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgTW9uZ29vc2VOTFEgPSB7XHJcbiAgICBNT05HT09TRV9NT0RFTE5BTUVfTUVUQU1PREVMUyA6IFwibWV0YW1vZGVsc1wiXHJcbn07XHJcbiJdfQ==
