'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.astToText = exports.dumpNodeNice = exports.typeToString = exports.makeNodeForInteger = exports.makeNodeForAny = exports.makeNodeForFact = exports.makeNodeForToken = exports.makeNodeForDomain = exports.makeNodeForCat = exports.makeNode = exports.NodeType = exports.ASTNodeType = void 0;
// based on: http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance
// and:  http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
const debugf = require("debugf");
const _ = require("lodash");
const debuglog = debugf('ast');
var ASTNodeType;
(function (ASTNodeType) {
    ASTNodeType[ASTNodeType["BINOP"] = 0] = "BINOP";
    ASTNodeType[ASTNodeType["OP"] = 1] = "OP";
    ASTNodeType[ASTNodeType["OPEqIn"] = 2] = "OPEqIn";
    ASTNodeType[ASTNodeType["OPContains"] = 3] = "OPContains";
    ASTNodeType[ASTNodeType["OPStartsWith"] = 4] = "OPStartsWith";
    ASTNodeType[ASTNodeType["OPEndsWith"] = 5] = "OPEndsWith";
    ASTNodeType[ASTNodeType["OPAll"] = 6] = "OPAll";
    ASTNodeType[ASTNodeType["OPFirst"] = 7] = "OPFirst";
    ASTNodeType[ASTNodeType["OPLatest"] = 8] = "OPLatest";
    ASTNodeType[ASTNodeType["OPNewest"] = 9] = "OPNewest";
    ASTNodeType[ASTNodeType["OPOldest"] = 10] = "OPOldest";
    ASTNodeType[ASTNodeType["CAT"] = 11] = "CAT";
    ASTNodeType[ASTNodeType["CATPH"] = 12] = "CATPH";
    ASTNodeType[ASTNodeType["FACT"] = 13] = "FACT";
    ASTNodeType[ASTNodeType["LIST"] = 14] = "LIST";
    ASTNodeType[ASTNodeType["ANY"] = 15] = "ANY";
    ASTNodeType[ASTNodeType["OPMoreThan"] = 16] = "OPMoreThan";
    ASTNodeType[ASTNodeType["OPLessThan"] = 17] = "OPLessThan";
    ASTNodeType[ASTNodeType["OPExactly"] = 18] = "OPExactly";
    ASTNodeType[ASTNodeType["OPLT"] = 19] = "OPLT";
    ASTNodeType[ASTNodeType["OPLE"] = 20] = "OPLE";
    ASTNodeType[ASTNodeType["OPNE"] = 21] = "OPNE";
    ASTNodeType[ASTNodeType["OPEQ"] = 22] = "OPEQ";
    ASTNodeType[ASTNodeType["OPGT"] = 23] = "OPGT";
    ASTNodeType[ASTNodeType["OPGE"] = 24] = "OPGE";
    ASTNodeType[ASTNodeType["OPOrderBy"] = 25] = "OPOrderBy";
    ASTNodeType[ASTNodeType["OPOrderDescendingBy"] = 26] = "OPOrderDescendingBy";
    ASTNodeType[ASTNodeType["OPExisting"] = 27] = "OPExisting";
    ASTNodeType[ASTNodeType["OPNotExisting"] = 28] = "OPNotExisting";
    ASTNodeType[ASTNodeType["OPLogicalAnd"] = 29] = "OPLogicalAnd";
    ASTNodeType[ASTNodeType["OPLogicalOr"] = 30] = "OPLogicalOr";
    ASTNodeType[ASTNodeType["NUMBER"] = 31] = "NUMBER";
    ASTNodeType[ASTNodeType["DOM"] = 32] = "DOM";
})(ASTNodeType = exports.ASTNodeType || (exports.ASTNodeType = {}));
class NodeType {
    constructor(nt) {
        this.nt = nt;
    }
    toString() {
        return astNodeTypes[this.nt];
    }
}
exports.NodeType = NodeType;
const astNodeTypes = ["BINOP",
    "OP",
    "OPEqIn",
    "OPContains",
    "OPStartsWith",
    "OPEndsWith",
    "OPAll",
    "OPFirst",
    "OPLatest",
    "OPNewest",
    "OPOldest",
    "CAT",
    "CATPH",
    "FACT",
    "LIST",
    "ANY",
    "OPMoreThan",
    "OPLessThan",
    "OPExactly",
    "OPLT",
    "OPLE",
    "OPNE",
    "OPEQ",
    "OPGT",
    "OPGE",
    "OPOrderBy",
    "OPOrderDescendingBy",
    "OPExisting",
    "OPNotExisting",
    "OPLogicalAnd",
    "OPLogicalOr",
    "NUMBER",
    "DOM"
];
;
function makeNode(type, ...args) {
    return {
        type: type,
        children: args
    };
}
exports.makeNode = makeNode;
function makeNodeForCat(cat) {
    return {
        type: ASTNodeType.CAT,
        bearer: cat
    };
}
exports.makeNodeForCat = makeNodeForCat;
function makeNodeForDomain(cat) {
    return {
        type: ASTNodeType.DOM,
        bearer: cat
    };
}
exports.makeNodeForDomain = makeNodeForDomain;
function makeNodeForToken(type, opToken) {
    return {
        type: type,
        bearer: opToken
    };
}
exports.makeNodeForToken = makeNodeForToken;
function makeNodeForFact(fact) {
    return {
        type: ASTNodeType.FACT,
        bearer: fact
    };
}
exports.makeNodeForFact = makeNodeForFact;
function makeNodeForAny(fact) {
    return {
        type: ASTNodeType.ANY,
        bearer: fact
    };
}
exports.makeNodeForAny = makeNodeForAny;
function makeNodeForInteger(inttok) {
    return {
        type: ASTNodeType.NUMBER,
        bearer: inttok
    };
}
exports.makeNodeForInteger = makeNodeForInteger;
function typeToString(type) {
    return astNodeTypes[type];
}
exports.typeToString = typeToString;
function dumpNodeNice(node) {
    if (!node) {
        return undefined;
    }
    var r = { type: typeToString(node.type) };
    r.index = getIndex(node);
    if (node.children && node.children.length) {
        r.children = node.children.map(n => dumpNodeNice(n));
    }
    return r;
}
exports.dumpNodeNice = dumpNodeNice;
function getIndex(node) {
    if (!node || !node.bearer) {
        return -1;
    }
    return node.bearer.startOffset;
}
function makePrefix(prefix, indent) {
    var s = '';
    for (var i = 0; i < indent * prefix; ++i) {
        s += ' ';
    }
    return s;
}
function astToText(node, indent, prefix) {
    prefix = prefix || 0;
    indent = indent || 2;
    debuglog(() => JSON.stringify(node, undefined, 2));
    var sprefix = makePrefix(prefix, indent);
    var index = getIndex(node);
    var ln = node ? `${typeToString(node.type)} ${index}` : '(undefined)';
    if (!node) {
        return sprefix + node + "\n";
    }
    if (node.children && typeof node.children.length === "number") {
        var schildren = node.children.map(c => astToText(c, indent, prefix + 1));
        return sprefix + ln + `(${schildren.length})` + '\n' + schildren.join('');
    }
    else {
        if (node.children && !_.isArray(node.children)) {
            throw new Error('weird children node' + node.children);
        }
    }
    return sprefix + ln + "\n";
}
exports.astToText = astToText;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QU0sS0FBSyxRQUFRLEVBQUU7UUFDMUQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDLE1BQU0sRUFBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxPQUFPLE9BQU8sR0FBRyxFQUFFLEdBQUcsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDN0U7U0FBTTtRQUNMLElBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdDLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3hEO0tBQ0Y7SUFDRCxPQUFPLE9BQU8sR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQzdCLENBQUM7QUFuQkQsOEJBbUJDIiwiZmlsZSI6ImFzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gYmFzZWQgb246IGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX2ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2VcclxuLy8gYW5kOiAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYW1lcmF1JUUyJTgwJTkzTGV2ZW5zaHRlaW5fZGlzdGFuY2VcclxuXHJcbmltcG9ydCAqIGFzIGRlYnVnZiBmcm9tICdkZWJ1Z2YnO1xyXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcbmNvbnN0IGRlYnVnbG9nID0gZGVidWdmKCdhc3QnKTtcclxuXHJcbmV4cG9ydCBlbnVtIEFTVE5vZGVUeXBlIHtcclxuICBCSU5PUCwgLy8wXHJcbiAgT1AsXHJcbiAgT1BFcUluLFxyXG4gIE9QQ29udGFpbnMsXHJcbiAgT1BTdGFydHNXaXRoLFxyXG4gIE9QRW5kc1dpdGgsXHJcbiAgT1BBbGwsXHJcbiAgT1BGaXJzdCxcclxuICBPUExhdGVzdCxcclxuICBPUE5ld2VzdCxcclxuICBPUE9sZGVzdCxcclxuICBDQVQsXHJcbiAgQ0FUUEgsXHJcbiAgRkFDVCxcclxuICBMSVNULCAvLzE0XHJcbiAgQU5ZLFxyXG4gIE9QTW9yZVRoYW4sXHJcbiAgT1BMZXNzVGhhbixcclxuICBPUEV4YWN0bHksXHJcbiAgT1BMVCxcclxuICBPUExFLFxyXG4gIE9QTkUsXHJcbiAgT1BFUSxcclxuICBPUEdULFxyXG4gIE9QR0UsXHJcbiAgT1BPcmRlckJ5LFxyXG4gIE9QT3JkZXJEZXNjZW5kaW5nQnksXHJcbiAgT1BFeGlzdGluZyxcclxuICBPUE5vdEV4aXN0aW5nLFxyXG4gIE9QTG9naWNhbEFuZCxcclxuICBPUExvZ2ljYWxPcixcclxuICBOVU1CRVIsXHJcbiAgRE9NXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBOb2RlVHlwZSB7XHJcbiAgICBudCA6IEFTVE5vZGVUeXBlO1xyXG4gIGNvbnN0cnVjdG9yKG50IDogQVNUTm9kZVR5cGUpIHtcclxuICAgIHRoaXMubnQgPSBudDtcclxuICB9XHJcbiAgdG9TdHJpbmcoKSA6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYXN0Tm9kZVR5cGVzW3RoaXMubnRdO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgYXN0Tm9kZVR5cGVzID0gIFsgXCJCSU5PUFwiLFxyXG4gIFwiT1BcIixcclxuICBcIk9QRXFJblwiLFxyXG4gIFwiT1BDb250YWluc1wiLFxyXG4gIFwiT1BTdGFydHNXaXRoXCIsXHJcbiAgXCJPUEVuZHNXaXRoXCIsXHJcbiAgXCJPUEFsbFwiLFxyXG4gIFwiT1BGaXJzdFwiLFxyXG4gIFwiT1BMYXRlc3RcIixcclxuICBcIk9QTmV3ZXN0XCIsXHJcbiAgXCJPUE9sZGVzdFwiLFxyXG4gIFwiQ0FUXCIsXHJcbiAgXCJDQVRQSFwiLFxyXG4gIFwiRkFDVFwiLFxyXG4gIFwiTElTVFwiLFxyXG4gIFwiQU5ZXCIsXHJcbiAgXCJPUE1vcmVUaGFuXCIsXHJcbiAgXCJPUExlc3NUaGFuXCIsXHJcbiAgXCJPUEV4YWN0bHlcIixcclxuICBcIk9QTFRcIixcclxuICBcIk9QTEVcIixcclxuICBcIk9QTkVcIixcclxuICBcIk9QRVFcIixcclxuICBcIk9QR1RcIixcclxuICBcIk9QR0VcIixcclxuICBcIk9QT3JkZXJCeVwiLFxyXG4gIFwiT1BPcmRlckRlc2NlbmRpbmdCeVwiLFxyXG4gIFwiT1BFeGlzdGluZ1wiLFxyXG4gIFwiT1BOb3RFeGlzdGluZ1wiLFxyXG4gIFwiT1BMb2dpY2FsQW5kXCIsXHJcbiAgXCJPUExvZ2ljYWxPclwiLFxyXG4gIFwiTlVNQkVSXCIsXHJcbiAgXCJET01cIlxyXG5dO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBU1ROb2RlIHtcclxuICB0eXBlIDogQVNUTm9kZVR5cGUsXHJcbiAgYmVhcmVyPyA6IGFueSxcclxuICBjaGlsZHJlbj8gOiBBU1ROb2RlW107XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vZGUodHlwZSA6IEFTVE5vZGVUeXBlLCAuLi4gIGFyZ3MgOiBBU1ROb2RlW10pIDogQVNUTm9kZSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGUgOiB0eXBlLFxyXG4gICAgY2hpbGRyZW4gOiBhcmdzXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vZGVGb3JDYXQoY2F0IDogYW55KSA6IEFTVE5vZGUge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlIDogQVNUTm9kZVR5cGUuQ0FULFxyXG4gICAgYmVhcmVyIDogY2F0XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOb2RlRm9yRG9tYWluKGNhdCA6IGFueSkgOiBBU1ROb2RlIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZSA6IEFTVE5vZGVUeXBlLkRPTSxcclxuICAgIGJlYXJlciA6IGNhdFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOb2RlRm9yVG9rZW4odHlwZSA6IEFTVE5vZGVUeXBlLCBvcFRva2VuIDogYW55KSA6IEFTVE5vZGUge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlIDogdHlwZSxcclxuICAgIGJlYXJlciA6IG9wVG9rZW5cclxuICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vZGVGb3JGYWN0KGZhY3QgOiBhbnkpIDogQVNUTm9kZSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGUgOiBBU1ROb2RlVHlwZS5GQUNULFxyXG4gICAgYmVhcmVyIDogZmFjdFxyXG4gIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9kZUZvckFueShmYWN0IDogYW55KSA6IEFTVE5vZGUge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlIDogQVNUTm9kZVR5cGUuQU5ZLFxyXG4gICAgYmVhcmVyIDogZmFjdFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOb2RlRm9ySW50ZWdlcihpbnR0b2sgOiBhbnkpIDogQVNUTm9kZSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGUgOiBBU1ROb2RlVHlwZS5OVU1CRVIsXHJcbiAgICBiZWFyZXIgOiBpbnR0b2tcclxuICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdHlwZVRvU3RyaW5nKHR5cGUgOiBBU1ROb2RlVHlwZSkge1xyXG4gIHJldHVybiBhc3ROb2RlVHlwZXNbdHlwZV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkdW1wTm9kZU5pY2Uobm9kZSA6IEFTVE5vZGUpIHtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHZhciByID0geyAgdHlwZSA6IHR5cGVUb1N0cmluZyhub2RlLnR5cGUpIH0gYXMgYW55O1xyXG4gICAgci5pbmRleCA9IGdldEluZGV4KG5vZGUpO1xyXG4gICAgaWYobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICByLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAobiA9PiBkdW1wTm9kZU5pY2UobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEluZGV4KG5vZGUgOiBBU1ROb2RlKSB7XHJcbiAgaWYoIW5vZGUgfHwgIW5vZGUuYmVhcmVyKSB7XHJcbiAgICByZXR1cm4gLTEgO1xyXG4gIH1cclxuICByZXR1cm4gbm9kZS5iZWFyZXIuc3RhcnRPZmZzZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VQcmVmaXgocHJlZml4IDogbnVtYmVyLCBpbmRlbnQgOiBudW1iZXIpIHtcclxuICB2YXIgcyA9ICcnO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbmRlbnQqcHJlZml4OyArK2kpIHtcclxuICAgIHMgKz0gJyAnO1xyXG4gIH1cclxuICByZXR1cm4gcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzdFRvVGV4dChub2RlIDogQVNUTm9kZSwgaW5kZW50PyA6IG51bWJlciwgcHJlZml4PyA6IG51bWJlcikge1xyXG4gIHByZWZpeCA9IHByZWZpeCB8fCAwO1xyXG4gIGluZGVudCA9IGluZGVudCB8fCAyO1xyXG4gIGRlYnVnbG9nKCgpID0+IEpTT04uc3RyaW5naWZ5KG5vZGUsdW5kZWZpbmVkLDIpKTtcclxuICB2YXIgc3ByZWZpeCA9IG1ha2VQcmVmaXgocHJlZml4LCBpbmRlbnQpO1xyXG4gIHZhciBpbmRleCA9ICBnZXRJbmRleChub2RlKTtcclxuICB2YXIgbG4gPSAgbm9kZSA/ICBgJHt0eXBlVG9TdHJpbmcobm9kZS50eXBlKX0gJHtpbmRleH1gIDogJyh1bmRlZmluZWQpJztcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHJldHVybiBzcHJlZml4ICsgbm9kZSArIFwiXFxuXCI7XHJcbiAgfVxyXG4gIGlmKG5vZGUuY2hpbGRyZW4gJiYgdHlwZW9mIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHZhciBzY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChjID0+IGFzdFRvVGV4dChjLGluZGVudCxwcmVmaXgrMSkpO1xyXG4gICAgICByZXR1cm4gc3ByZWZpeCArIGxuICsgYCgke3NjaGlsZHJlbi5sZW5ndGh9KWAgKyAnXFxuJyArIHNjaGlsZHJlbi5qb2luKCcnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYobm9kZS5jaGlsZHJlbiAmJiAhXy5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2VpcmQgY2hpbGRyZW4gbm9kZScgKyBub2RlLmNoaWxkcmVuKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNwcmVmaXggKyBsbiArIFwiXFxuXCI7XHJcbn0iXX0=
